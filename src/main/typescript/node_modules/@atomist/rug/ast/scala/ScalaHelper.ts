
import {TreeNode,TextTreeNode,ParentAwareTreeNode,PathExpression,Match,PathExpressionEngine} from "../../tree/PathExpression"
import {TransformingPathExpressionEngine} from "../../tree/TransformingPathExpressionEngine"

import {AstHelper} from "../AstHelper"

import {File} from "../../model/Core"

import * as scala from "./Types"

export abstract class DecoratingPathExpressionEngine extends TransformingPathExpressionEngine {

    constructor(delegate: PathExpressionEngine) {
        super(delegate, n => {
            console.log(`Trying to combine with n=${n.nodeName()}`)
            // Also need to parameterize module
            let ops = this.decoratorFor(n)
            //console.log("Created ops")
            let combined = this.unify(n, ops)
            //console.log(`ops=${ops}, combined=${combined}`)
            return combined
        })
    }

     /**
    * Add all functions from right to left.
    * Also copies state, which is needed for methods to work.
    */
    protected unify<T, U>(base: T, enricher: U): T & U {
        let monkeyableBase = base as any
        for (let id in enricher) {
            //monkeyableBase.id = (<any>enricher)[id];
            let fun = (<any>enricher)[id]
            monkeyableBase[id] = fun
            //console.log(`Adding function ${id} from right to left: ${fun} from source ${enricher}`)
        }
        return monkeyableBase as T & U;
    }

    protected abstract decoratorFor(n: TreeNode): any


    protected decoratorClassName(n: TreeNode) {
        return "TermApply" + "InfixOps"
    }

}

// TODO only in separate module due to inability to reference module for create [""]
export class ScalaPathExpressionEngine extends DecoratingPathExpressionEngine {

    protected decoratorFor(n: TreeNode): any {
        let className = this.decoratorClassName(n)
        let ops = new scala[className](n)
        return ops
    }
}

/**
 * Helpers for working with Scala classes. This shows a common pattern:
 * We work with a tree and Strings, but within that, encapsulate 
 * common operations and path expressions.
 */
export class ScalaHelper extends AstHelper {

    public constructor(pexe: PathExpressionEngine) {
        super(pexe)
    }

    /**
     * Add the import if not already imported.
     * Invalidates the file. Returns the new language type node (under file).
     */
    addImport(scalaNode: scala.ScalaSource, newImport: string): TextTreeNode {
        let fullNewImport = `import ${newImport}`

        if (scalaNode.value().indexOf(fullNewImport) == -1) {
            let firstImport = `//import[1]`

            this.pexe.with<TextTreeNode>(scalaNode, firstImport, existingImport => {
                let newValue = `${existingImport.value()}\n${fullNewImport}`
                //console.log(`Replacing [${existingImport.value()}] with [${newValue}]`)
                existingImport.update(newValue)
            })
        }
        else {
            //console.log(`Already has import ${newImport}`)
        }
    
        return super.reparseNodeUnderFile(scalaNode, "ScalaFile")
    }

}