
import { RichTextTreeNode } from "../TextTreeNodeOps";
import { DecoratingPathExpressionEngine } from "../DecoratingPathExpressionEngine";


export function union(eng: DecoratingPathExpressionEngine, root: RichTextTreeNode, pe1: string, pe2: string): RichTextTreeNode[] {
    let hits1: RichTextTreeNode[] = eng.save<RichTextTreeNode>(root, pe1)
    let hits2: RichTextTreeNode[] = eng.save<RichTextTreeNode>(root, pe2)
    console.log("hits1=" + hits1 + "\nhits2=" + hits2 + "\nlen1=" + hits1.length + "\nlen2=" + hits2.length);

    return hits1.concat(hits2);
}


/**
 * Convenient class to wrap Java methods, hiding AST navigation.
 */
export class Method {

    annotations: RichTextTreeNode[] = [];

    constructor(private eng: DecoratingPathExpressionEngine, public methodDeclaration: RichTextTreeNode) {
        this.annotations = union(eng, this.methodDeclaration,
               "/methodHeader//annotation",
               "//methodModifier//annotation"
                );

    }

    private nameNode(): RichTextTreeNode {
        return this.eng.scalar<RichTextTreeNode,RichTextTreeNode>(this.methodDeclaration,
        "/methodHeader/methodDeclarator/Identifier");
    }

    filePath: string = this.methodDeclaration.containingFile().path;

    name: string = this.nameNode().value();

    rename(newName: string): void {
        this.nameNode().update(newName);
    }
}