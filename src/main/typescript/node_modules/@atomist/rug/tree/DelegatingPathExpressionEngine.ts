import {PathExpressionEngine,PathExpression,Match,DynamicType,TreeNode} from "./PathExpression"

export class DelegatingPathExpressionEngine implements PathExpressionEngine {

  constructor(protected delegate: PathExpressionEngine,
      private nodeTransform: (TreeNode) => TreeNode) {}

  addType(dt: DynamicType): PathExpressionEngine {
    return this.delegate.addType(dt)
  }

  evaluate<R extends TreeNode,N extends TreeNode>(root: R, expr: PathExpression<R,N>): Match<R,N> {
    return this.delegate.evaluate(root, expr)
  }

  with<N extends TreeNode>(root: TreeNode, expr: string,
            f: (n: N) => void): void {
    this.delegate.with(root, expr, n => {
        //console.log("Intercepted with")
        let transformed = this.nodeTransform(n)
        //console.log(`Transformed is ${transformed}`)
        f(transformed as N)
    })
  }

  scalar1<R extends TreeNode,N extends TreeNode>(root: R, expr: PathExpression<R,N>): N {
    return this.delegate.scalar1<R,N>(root, expr)
  }

  scalar<R extends TreeNode,N extends TreeNode>(root: R, expr: string): N {
    let n = this.delegate.scalar<R,N>(root, expr)
    console.log(`Delegated superclass intercepted ${expr} on ${n},tags = ${n.nodeTags()}`)
    return n
  }

  as<N extends TreeNode>(root, name: string): N {
    return this.delegate.as<N>(root, name)
  }

  // Find the children of the current node of this time
  children<N extends TreeNode>(root, name: string): N[] {
    return this.delegate.children<N>(root, name)
  }

}