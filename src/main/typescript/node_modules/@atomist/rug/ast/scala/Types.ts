
/**
 * Module containing Scala types. 1:1 mapping to grammar productions.
 * Purely a convenience for TypeScript users: Can be ignored in JavaScript.
 * Ultimately, such interfaces can be generated.
 */

import {TextTreeNode} from "../../tree/PathExpression"

export interface ScalaSource extends TextTreeNode {
     
    // TODO file, filename etc? Common extends?

}

export interface TermApplyInfixNav extends TextTreeNode {
     
    termSelect(): any

    termApply(): any

}

export class TermApplyInfixOps {

    constructor(private nav: TermApplyInfixNav) {}

    absquatulate() {
        console.log(`TermApplyInfixOps.absquatulate with ${this.nav.nodeName()}`)
    }

}

// export function extend<T, U>(first: T, second: U): T & U {
//     let result = <T & U>{};
//     console.log(`first is ${first}`)
//     for (let id in first) {
//         (<any>result)[id] = (<any>first)[id];
//         console.log(`From left: ${id}`)
//     }
//     for (let id in second) {
//         if (!result.hasOwnProperty(id)) {
//             (<any>result)[id] = (<any>second)[id];
//             console.log(`From right: ${id}`)
//         }
//     }
//     return result;
// }

/**
 * Add all functions from right to left.
 * Also copies state, which is needed for methods to work.
 */
export function unify<T, U>(base: T, enricher: U): T & U {
    let monkeyableBase = base as any
    for (let id in enricher) {
        //monkeyableBase.id = (<any>enricher)[id];
        let fun = (<any>enricher)[id]
        monkeyableBase[id] = fun
        //console.log(`Adding function ${id} from right to left: ${fun} from source ${enricher}`)
    }
    return monkeyableBase as T & U;
}

export type TermApplyInfix = TermApplyInfixNav & TermApplyInfixOps