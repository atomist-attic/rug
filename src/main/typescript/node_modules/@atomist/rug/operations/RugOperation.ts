
import {PathExpressionEngine, PathExpression} from "../tree/PathExpression"

/**
 * Superinterface for all Rug operations, enabling cataloging.
 */
interface RugOperation {
  readonly name: string
  readonly tags?: string[]
  readonly description: string
  readonly parameters?: Parameter[]
}

/**
 * Well-known patterns used in operation parameters.
 */
abstract class Pattern {
  public static url: string ="@java_package"
  public static any: string ="@any"
  public static group_id: string ="@group_id"
  public static artifact_id: string = "@artifact_id"
  public static java_class: string ="@java_class"
  public static java_identifier: string ="@java_identifier"
  public static java_package: string ="@java_package"
  public static project_name: string ="@project_name"
  public static port: string ="@port"
  public static ruby_class: string ="@ruby_class"
  public static ruby_identifier: string ="@ruby_identifier"
  public static semantic_version: string ="@semantic_version"
  public static version_range: string ="@version_range"
  public static uuid: string ="@uuid"
}

interface BaseParameter {
  readonly pattern: string
  readonly required?: boolean
  readonly description?: string
  readonly displayName?: string
  readonly validInput?: string
  readonly displayable?: boolean
  readonly maxLength?: number
  readonly minLength?: number
  readonly tags?: string[]
}

interface Parameter extends BaseParameter{
  readonly name: string
  readonly default?: string
}


/**
 * Status of an operation.
 */
enum Status {
    Success,
    NoChange,
    Error
}

/**
 * Result of running an editor
 */
class Result {
    constructor(
        public status: Status,
        public message: string = "") {}
}

/**
 * Severity of a comment from a review
 */
enum Severity {
  Fine,
  Polish,
  Major,
  Broken
}

/**
 * A comment from a review
 */
class ReviewComment {
  constructor(
      public comment: string,
      public severity: Severity,
      public fileName?: string,
      public line?: number,
      public column?: number) {}
}

/**
 * Result of running a reviewer
 */
class ReviewResult {

  constructor(
      public note: string,
      public comments: ReviewComment[]) {}

  add(rc: ReviewComment) {
    this.comments.push(rc)
  }

  static empty(note: string): ReviewResult {
    return new ReviewResult(note, [])
  }

  /**
   * Combine the results of the given reviewers
   * @param results review results to combine
   */
  static combine(results: ReviewResult[]): ReviewResult {
    if (results.length == 0)
      throw new Error("Invalid argument: Need at least one review result")
    let combinedComments: ReviewComment[] = []
    results.forEach(r => 
      r.comments.forEach(
        c => combinedComments.push(c)
      )
    )
    return new ReviewResult(
      results.map(r => r.note).join(","),
      combinedComments
    )
  }
}

export {RugOperation, Parameter, Pattern, Result, Status, ReviewResult, ReviewComment, Severity, BaseParameter}
