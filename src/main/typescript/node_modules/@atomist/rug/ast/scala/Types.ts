
/**
 * Module containing Scala types. 1:1 mapping to grammar productions.
 * Purely a convenience for TypeScript users: Can be ignored in JavaScript.
 * Ultimately, such interfaces can be generated.
 */

import {TreeNode,PathExpression,PathExpressionEngine,Match,TextTreeNode} from "../../tree/PathExpression"

export interface ScalaSource extends TextTreeNode {
     
    // TODO file, filename etc? Common extends?

}

export interface TermApplyInfixNav extends TextTreeNode {
     
    termSelect(): any

    termApply(): any

}

export class TermApplyInfixOps {

    constructor(private nav: TermApplyInfixNav) {}

    absquatulate() {
        console.log(`TermApplyInfixOps.absquatulate with ${this.nav.nodeName()}`)
    }

    reverseShould() {
        console.log(`New reverse should`)
        let termSelect = this.nav.termSelect()
        let termApply = this.nav.termApply()

        if (termApply != null && ["be", "equal"].indexOf(termApply.termName().value()) > -1) {
          let newValue = `assert(${termSelect.value()} === ${termApply.children()[1].value()})`
          //console.log(`Replacing [${shouldTerm.value()}] with [${newValue}]`)
          this.nav.update(newValue)
        }
    }

}

// export function extend<T, U>(first: T, second: U): T & U {
//     let result = <T & U>{};
//     console.log(`first is ${first}`)
//     for (let id in first) {
//         (<any>result)[id] = (<any>first)[id];
//         console.log(`From left: ${id}`)
//     }
//     for (let id in second) {
//         if (!result.hasOwnProperty(id)) {
//             (<any>result)[id] = (<any>second)[id];
//             console.log(`From right: ${id}`)
//         }
//     }
//     return result;
// }

export type TermApplyInfix = TermApplyInfixNav & TermApplyInfixOps