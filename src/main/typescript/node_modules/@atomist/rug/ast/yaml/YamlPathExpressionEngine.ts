
import {TreeNode} from "../../tree/PathExpression"
import {DecoratingPathExpressionEngine} from "../DecoratingPathExpressionEngine"

import {TextTreeNode} from "../../tree/PathExpression"

/**
 * PathExpressionEngine decorator that returns Yaml type mixins
 * for value nodes. 
 */
export class YamlPathExpressionEngine extends DecoratingPathExpressionEngine {

    protected decoratorFor(n: TreeNode): YamlValueOps {
        if (n.nodeName() == "value" && (<any>n).value) {
            console.log(`Decorating [${n}]`)
            let ttn = n as TextTreeNode
            if (ttn.value().charAt(0) == '"')
                return new QuotedValue(ttn)
            else if (ttn.value().charAt(0) == '>')
                return new BlockChompedValue(ttn)
            else
                return new RawValue(ttn)
        }
        else 
            return null
    }
}

/**
 * Extended by classes that know how to handle YAML strings.
 * We need to transform them on return and on update.
 */
export interface YamlValueOps {

    /**
     * Returns the actual text, not the raw value,
     * which may contain quotes etc
     */
    text(): string

    /**
     * Update the actual text, taking care of quotes, newlines etc
     */
    updateText(to: string): void

}

export type YamlValue = YamlValueOps & TextTreeNode

/**
 * String without quotes or newlines. Leave it alone.
 */
class RawValue implements YamlValueOps {

    constructor(private node: TextTreeNode) {}

    text() {
        return this.node.value()
    }

    updateText(to: string) {
        this.node.update(to)
    }
}

/**
 * String enclosed in "". Simply strip them.
 */
class QuotedValue implements YamlValueOps {

    constructor(private node: TextTreeNode) {}

    text() {
        return this.node.value().slice(1, this.node.value().length - 1)
    }

    updateText(to: string) {
        let newValue = `"${to}"`
        console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using >. Strip newlines.
 */
// TODO various ways of handling trailing newlines: -, +
class BlockChompedValue implements YamlValueOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '>') throw new Error("Illegal argument: Must begin with >")
        if (raw.charAt(1) != '\n') throw new Error("Illegal argument: Must begin with >\n")
        let index = 2
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(2)
    }

    text() {
        return this.node.value().substr(this.leading.length).replace("\n", " ")
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}