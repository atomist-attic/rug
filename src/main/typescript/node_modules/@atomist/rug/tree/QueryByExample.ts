
import {GraphNode,AddressedGraphNode,PathExpression} from "./PathExpression"

/**
 * Create a query for this node. Predicates for its tree.
 * Doesn't insist on a GraphNode parameter as it could be a JSON structure with the required
 * properties instead
 */
export function queryByExample<G extends GraphNode>(g: any): PathExpression<GraphNode,G> {
    return new PathExpression<GraphNode,G>(`/${queryByExampleString(g)}`)
}

/**
 * Add address to every node in the graph
 */
export function addAddressesToGraph(g: any): void {
    queryByExampleString(g, true)
}

function queryByExampleString(g: any, addAddresses: boolean = false, addressBase: string = "/"): string {
    let pe = typeToAddress(g)
    let address = addressBase + pe
    for (let id in g) {
        let propOrFun = g[id]
        let value: any = ""
        if (isRelevantFunction(id, propOrFun)) {
            console.log(`${id}=${propOrFun} with pe start = [${pe}]`)
            // Put the address in this object
            value = g[id]()
        }
        else if (isRelevantProperty(id, propOrFun)) {
            value = g[id]
            console.log(`Property ${id} returned ${value}`)
        }
        if (!value) {
            // Ignore
        }
        else if (value.nodeTags && value.nodeName) { // Simple test for graph node type
            //console.log(`GraphNode Target=${target}`)
            let step = `/${id}::${queryByExampleString(value, addAddresses)}`
            pe += `[${step}]`
            address += step
        }
        else if (["string", "number", "boolean"].indexOf(typeof value) != -1) {
            // It's probably a simple property
            console.log(`Non graph node result of invoking ${id} was [${value}]`)
            pe += `[@${id}='${value}']`
        }
        else {
            console.log(`Don't know what to do with unfamiliar result of invoking ${id} was [${value}]`)
        }
    }
    if (addAddresses) {
        g["address"] = function() { return address }
        console.log(`Address of ${g.nodeName()} is ${g.address()}`)
    }
    return pe
}

function typeToAddress(g: any): string {
    // TODO fragile. Or is this a convention we can rely on?
    return isFunction(g.nodeTags) ? `${g.nodeTags()[0]}()` : `${g.nodeTags[0]}()`
}

/**
 * Is this a function we care about? 
 */
function isRelevantFunction(id: string, f): boolean {
    return isFunction(f) && ["nodeTags", "nodeName", "address", "constructor", "navigatedFrom"].indexOf(id) == -1 &&
        id.indexOf("with") != 0
}

function isRelevantProperty(id: string, p): boolean {
    return !isFunction(p) && ["nodeTags", "nodeName"].indexOf(id) == -1 &&
        id.indexOf("_") != 0
}

function isFunction(obj) {
  return !!(obj && obj.constructor && obj.call && obj.apply);
};