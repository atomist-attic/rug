
import {TreeNode,TextTreeNode,ParentAwareTreeNode,PathExpressionEngine} from "../tree/PathExpression"
import {TreeHelper} from "../tree/TreeHelper"

import {File} from "../model/Core"

/**
 * Helpers for working with Scala classes. This shows a common pattern:
 * We work with a tree and Strings, but within that, encapsulate 
 * common operations and path expressions.
 */
export class ScalaHelper {

    public constructor(public pexe: PathExpressionEngine) {}

    private treeHelper = new TreeHelper()

    /**
     * Add the import if not already imported.
     * Invalidates the file. Returns the new language type node (under file).
     */
    importIfNotImported(scalaNode: TextTreeNode, newImport: string): TextTreeNode {
        scalaNode.update("class Hello")
        return this.reparseNodeUnderFile(scalaNode, "ScalaFile")
    }

    /**
     * Reparse this file. 
     * TODO should go to a superclass that spans different nodes.
     */
    reparseNodeUnderFile(languageNode: TextTreeNode, type: String): TextTreeNode {
        let p = languageNode.parent() as any
        if (p && p.filename) {
            // It's a file node
            let f = p as File
            console.log(`Need to update parent node`)
            let pathExpression = `/${type}`
            let r = this.pexe.scalar<File,TextTreeNode>(f, pathExpression)
            return r
        }
        else {
            throw new Error(`Parent node ${p} doesn't seem to a File`)
        }
    }

}