
/**
 * Module containing Scala types. 1:1 mapping to grammar productions.
 * Purely a convenience for TypeScript users: Can be ignored in JavaScript.
 * Ultimately, such interfaces can be generated.
 */

import {TreeNode,PathExpression,PathExpressionEngine,Match,TextTreeNode} from "../../tree/PathExpression"
import {NodeOps} from "../NodeOps"

export interface SourceNav extends TextTreeNode {
     
}

export class SourceOps extends NodeOps<SourceNav> {

    addImport(newImport: string): void {
        console.log(`In new add import`)
        let fullNewImport = `import ${newImport}`

        if (this.node.value().indexOf(fullNewImport) == -1) {
            let firstImport = `//import[1]`

            this.pexe.with<TextTreeNode>(this.node, firstImport, existingImport => {
                let newValue = `${existingImport.value()}\n${fullNewImport}`
                //console.log(`Replacing [${existingImport.value()}] with [${newValue}]`)
                existingImport.update(newValue)
            })
        }
    }
}

export type Source = SourceNav & SourceOps

export interface TermApplyInfixNav extends TextTreeNode {
     
    termSelect(): any

    termApply(): any

}

export class TermApplyInfixOps extends NodeOps<TermApplyInfix> {

    reverseShould() {
        console.log(`New reverseShould: PathExpressionEngine=${this.pexe}`)
        console.log(`Containing file=${this.containingFile()}`)
        let termSelect = this.node.termSelect()
        let termApply = this.node.termApply()

        if (termApply != null && ["be", "equal"].indexOf(termApply.termName().value()) > -1) {
          let newValue = `assert(${termSelect.value()} === ${termApply.children()[1].value()})`
          //console.log(`Replacing [${shouldTerm.value()}] with [${newValue}]`)
          this.node.update(newValue)
        }
    }

}

export type TermApplyInfix = TermApplyInfixNav & TermApplyInfixOps