import {TreeNode, PathExpressionEngine, PathExpression, Match} from "../tree/PathExpression"
import {Parameter, Secret} from "./RugOperation"
import {Project} from "../model/Core"

interface RugCoordinate {
  readonly name: string
  readonly group: string
  readonly artifact: string
  readonly version?: string
}

type InstructionKind = "generate" | "edit" | "review" | "execute" | "respond" | "command"

interface Instruction<T extends InstructionKind> {
  readonly name: string | RugCoordinate
  readonly parameters?: Json
  readonly kind: T
  readonly label?: string
  onSuccess?: Plan | Message | Respond
  onError?: Plan | Message | Respond
}

interface ProjectInstruction<T extends InstructionKind> extends Instruction<T> {
  project: Project
}

interface Review extends ProjectInstruction<"review"> {

}

interface Edit extends ProjectInstruction <"edit">{

}

interface Generate extends Instruction <"generate">{

}

interface Execute extends Instruction<"execute">{

}

interface Command extends Instruction<"command">{

}

interface Respond extends Instruction<"respond">{

}

interface CommandHandler{
  readonly name: string
  readonly description: string
  readonly intent?: string[]
  readonly parameters?: Parameter[]
  readonly secrets?: Secret[]
  readonly tags?: string[]
  handle(ctx: CommandContext): Plan | Message
}

interface EventHandler<R extends TreeNode, M extends TreeNode> {
  readonly name: string
  readonly description: string
  readonly tags?: string[]
  readonly expression: PathExpression<R,M> | string
  handle(root: Match<R,M>): Plan | Message
}

interface CommandContext {
  pathExpressionEngine(): PathExpressionEngine
}

interface Response<T> {
  readonly status: string
  readonly code: number
  readonly body?: T
}

/**
A bunch of stuff to do asynchronously
Messages got to the bot.
Rugs are run straight away
*/

type Plannable = Message | Edit | Generate | Review | Execute | Command

class Plan {
   private messages: Message[] = [];
   private instructions: Plannable[] = [];
   public add?(thing: Plannable): this {
     if(thing instanceof Message){
       this.messages.push(thing)
     }else{
        this.instructions.push(thing)
     }
     return this;
   }
}
/**
Represents a Message to the bot.
Any rugs can contain unbound parameters, and the bot will try to fill them out
*/
class Message {
  text?: string;
  body?: Json;
  channelId?: string;
  node?: TreeNode;
  instructions?: Plannable[]

  constructor(about: string | Json){
    if(typeof about == 'string'){
        this.text = about;
    }else{
        this.body = about;
    }
  }

  public regarding?(node: TreeNode) : this {
    this.node = node;
    return this;
  }

  public addAction?(rug: Plannable): this {
    this.instructions.push(rug)
    return this;
  }
}

//from https://github.com/Microsoft/TypeScript/issues/1897
interface Json {
	[x: string]: string | number | boolean | Date | Json | JsonArray;
}

interface JsonArray extends Array<string | number | boolean | Date | Json | JsonArray> { }

export {Instruction, CommandHandler, Secret, EventHandler, Response, CommandContext, Plan, Message, PathExpression}
