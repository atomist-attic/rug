import {Addressed,TreeNode,TextTreeNode,ParentAwareTreeNode} from "./PathExpression"

export function hasTag(n: TreeNode, t: string): boolean {
    return n.nodeTags().indexOf(t) > -1
}

/**
 * Helper functions for working with TreeNodes in simple
 * cases where we don't need a path expression.
 */
export class TreeHelper {

    findPathFromAncestor(n: ParentAwareTreeNode, nodeTest: (TextTreeNode) => boolean): string {
        let parent = n.parent() as any // Makes checking for parent function later easy
        if (parent == null) {
            // We couldn't resolve the path
            return null
        }
        else if (nodeTest(parent)) {
            //console.log(`Gotcha: Parent is ${parent}`)
            // TODO what if it's not unique - need position, but then parent.children may reinitialize.
            // Not if a mutable container, admittedly
            return `/${n.nodeName()}`
        }
        else if (parent.parent()) { // Essentially an instanceof, which we can't do on an interface
            return this.findPathFromAncestor(parent as ParentAwareTreeNode, nodeTest) + `/${n.nodeName()}`
        }
        else
            return null
    }

    findPathFromAncestorWithTag(n: ParentAwareTreeNode, tag: String): string {
        let r = this.findPathFromAncestor(
            n,
            n => n.nodeTags().contains(tag))
        return r
    }

    /**
     * Return an ancestor meeting the given criteria
     * or null if it cannot be found
     */
    findAncestor<N extends TreeNode>(n: ParentAwareTreeNode, nodeTest: (N) => boolean): N {
        let parent = n.parent() as any // Makes checking for parent function later easy
        if (parent == null) {
            return null
        }
        else if (nodeTest(parent)) {
            //console.log(`Gotcha: Parent is ${parent}`)
            return parent as N
        }
        else if (parent.parent()) { // Essentially an instanceof, which we can't do on an interface
            return this.findAncestor(parent as ParentAwareTreeNode, nodeTest) as N
        }
        else
            return null
    }

    /**
     * Find an ancestor with a given tag
     */
    findAncestorWithTag<N extends TreeNode>(n: ParentAwareTreeNode, tag: string): N {
        let r = this.findAncestor<N>(
            n,
            n => n.nodeTags().contains(tag))
        return r
    }
}

export abstract class AddressedNodeSupport implements Addressed {

    private _navigatedFrom: Addressed = null
    private step: string

    address() {
        return this._navigatedFrom ?
            this._navigatedFrom.address() + this.step :
            ""
    }

    /**
     * We got to here from the given node, via the given step.
     * Still works even if the address of the node changes,
     * as it may during building in test
     */
    navigatedFrom(navigatedFrom: Addressed, step: string) {
        if (navigatedFrom == this)
            throw new Error(`Illegal cycle at ${this}`)
        this._navigatedFrom = navigatedFrom
        this.step = step
    }
    
}