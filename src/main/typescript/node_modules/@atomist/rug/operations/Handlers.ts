import { GraphNode, TreeNode, PathExpressionEngine, PathExpression, Match } from "../tree/PathExpression"
import { Parameter } from "./RugOperation"

export interface RugCoordinate {
  readonly name: string
  readonly group: string
  readonly artifact: string
}

type InstructionKind = "generate" | "edit" | "execute" | "respond" | "command"

export interface Instruction<T extends InstructionKind> {
  readonly name: string | RugCoordinate
  readonly parameters?: {}
  readonly kind: T
}

export class EventRespondable<T extends Edit | Generate | Execute> {
  instruction: T
  onSuccess?: EventPlan | EventMessage | Respond
  onError?: EventPlan | EventMessage | Respond
}

export class CommandRespondable<T extends Edit | Generate | Execute | Command> {
  instruction: T
  onSuccess?: CommandPlan | CommandMessage | Respond
  onError?: CommandPlan | CommandMessage | Respond
}

export class Presentable<T extends InstructionKind> {
  instruction: Instruction<T> | PresentableGenerate | PresentableEdit
  label?: string
}

// Location to a project.
// in the future, we could add things like github urls, orgs etc.
interface ProjectReference {}

export interface ProjectInstruction<T extends InstructionKind> extends Instruction<T> {
  project: string | ProjectReference
}

export interface Edit extends ProjectInstruction<"edit"> {}

//extends ProjectInstruction because we need to know the project name
export interface Generate extends ProjectInstruction<"generate"> {}

//because in a message, we may not know project name yet
export interface PresentableGenerate extends Instruction<"generate"> {
  project?: string | ProjectReference
}

//because in a message, we may not know project name yet
export interface PresentableEdit extends Instruction<"edit"> {
  project?: string | ProjectReference
}

export interface Execute extends Instruction<"execute"> {}

export interface Respond extends Instruction<"respond"> {}

export interface Command extends Instruction<"command"> {}

export interface HandleCommand {
  handle(ctx: HandlerContext): CommandPlan
}

export interface HandleEvent<R extends GraphNode, M extends GraphNode> {
  handle(root: Match<R, M>): EventPlan
}

export interface HandleResponse<T> {
  handle(response: Response<T>): EventPlan | CommandPlan
}

/**
 * Context available to all handlers. Unique to a team.
 * Exposes a context root from which queries can be run,
 * using the given PathExpressionEngine
 */
export interface HandlerContext {

  /**
   * Id of the team we're working on behalf of
   */
  teamId: string

  pathExpressionEngine: PathExpressionEngine

  /**
   * The root of this team's context. Allows execution
   * of path expressions.
   */
  contextRoot: GraphNode
}

export enum Status {
  failure,
  success
}

export interface Response<T> {
  msg: string
  code: number
  status: Status
  body: T
}

type Respondable = EventRespondable<any> | CommandRespondable<any>

/**
 * A bunch of stuff to do asynchronously
 * PlanMessages got to the bot.
 * ImmediatelyRunnables are run straight away
 */
export abstract class Plan {

  instructions: Respondable[] = [];

  messages: PlanMessage[] = [];

  public add?(thing: Respondable | PlanMessage): this {
    if (thing instanceof ResponseMessage || thing instanceof DirectedMessage || thing instanceof LifecycleMessage) {
      this.messages.push(thing);
    } else {
      this.instructions.push(thing);
    }
    return this;
  }
}


type EventMessage = LifecycleMessage | DirectedMessage

type CommandMessage = ResponseMessage | DirectedMessage

/**
 * For returning from Event Handlers
 */
export class EventPlan extends Plan {

  public add?(msg: EventMessage | EventRespondable<any>): this {
    return super.add(msg);
  }

  static ofMessage(m: EventMessage): EventPlan {
    return new EventPlan().add(m);
  }
}

/**
 * Plans returned from Command Handlers
 */
export class CommandPlan extends Plan {

  public add?(msg: CommandMessage | CommandRespondable<any>): this {
    return super.add(msg);
  }

  static ofMessage(m: CommandMessage): CommandPlan {
    return new CommandPlan().add(m);
  }
}

export type MessageMimeType = "application/x-atomist-slack+json" | "text/plain"

export abstract class MessageMimeTypes {
  public static SLACK_JSON: MessageMimeType = "application/x-atomist-slack+json"
  public static PLAIN_TEXT: MessageMimeType = "text/plain"
}

type MessageKind = "response" | "lifecycle" | "directed"

interface Message<T extends MessageKind> {
  kind: T
}

/**
 * Represents the response to the bot from a command
 */
export class ResponseMessage implements Message<"response"> {

  kind: "response" = "response"
  body: string;
  contentType: MessageMimeType = MessageMimeTypes.PLAIN_TEXT
  usernames?: string[] = [];
  channelNames?: string[] = [];

  constructor(body: string, contentType?: MessageMimeType) {
    this.body = body;
    if (contentType) {
      this.contentType = contentType;
    }
  }

  public addAddress?(address: MessageAddress): this {
    if (address instanceof UserAddress) {
      this.usernames.push(address.username);
    }
    else {
      this.channelNames.push(address.channelName);
    }
    return this;
  }
}

export class UserAddress {
  constructor(public username: string) { }
}

export class ChannelAddress {
  constructor(public channelName: string) { }
}

export type MessageAddress = UserAddress | ChannelAddress

/**
 * Uncorrelated message to the bot
 */
export class DirectedMessage implements Message<"directed"> {

  kind: "directed" = "directed"
  contentType: MessageMimeType = MessageMimeTypes.PLAIN_TEXT
  body: string;
  usernames?: string[] = [];
  channelNames?: string[] = [];

  constructor(body: string, address: MessageAddress, contentType?: MessageMimeType) {
    this.body = body;
    if (contentType) {
      this.contentType = contentType;
    }
    this.addAddress(address);
  }

  public addAddress?(address: MessageAddress): this {
    if (address instanceof UserAddress) {
      this.usernames.push(address.username);
    }
    else {
      this.channelNames.push(address.channelName);
    }
    return this;
  }
}

/**
 * Correlated, updatable messages to the bot
 */
export class LifecycleMessage implements Message<"lifecycle">{

  kind: "lifecycle" = "lifecycle"
  node: GraphNode;
  instructions?: Presentable<any>[] = [];
  lifecycleId: string;

  constructor(node: GraphNode, lifecycleId: string) {
    this.node = node;
    this.lifecycleId = lifecycleId;
  }

  public addAction?(instruction: Presentable<any>): this {
    this.instructions.push(instruction);
    return this;
  }
}

export type PlanMessage = ResponseMessage | DirectedMessage | LifecycleMessage

export abstract class MappedParameters {
  static readonly GITHUB_REPO_OWNER: string = "atomist://github/repository/owner"
  static readonly GITHUB_REPOSITORY: string = "atomist://github/repository"
  static readonly SLACK_CHANNEL: string = "atomist://slack/channel"
  static readonly SLACK_TEAM: string = "atomist://slack/team"
  static readonly SLACK_USER: string = "atomist://slack/user"
  static readonly GITHUB_WEBHOOK_URL: string = "atomist://github_webhook_url"
}

