import { GraphNode, TreeNode, PathExpressionEngine, PathExpression, Match } from "../tree/PathExpression"
import { Parameter } from "./RugOperation"

interface RugCoordinate {
  readonly name: string
  readonly group: string
  readonly artifact: string
}

type InstructionKind = "generate" | "edit" | "review" | "execute" | "respond" | "command"

interface Instruction<T extends InstructionKind> {
  readonly name: string | RugCoordinate
  readonly parameters?: {}
  readonly kind: T
}

interface ImmediatelyRunnable { }

class Respondable<T extends Review | Edit | Generate | Execute> implements ImmediatelyRunnable {
  instruction: T
  onSuccess?: Plan | PlanMessage | Respond
  onError?: Plan | PlanMessage | Respond
}

class NonRespondable<T extends Command | Respond> implements ImmediatelyRunnable {
  instruction: T
}

class Presentable<T extends InstructionKind> {
  instruction: Instruction<T> | PresentableGenerate | PresentableEdit | PresentableReview
  label?: string
}

// Location to a project.
// in the future, we could add things like github urls, orgs etc.
interface ProjectReference {

}

interface ProjectInstruction<T extends InstructionKind> extends Instruction<T> {
  project: string | ProjectReference
}

interface Review extends ProjectInstruction<"review"> {

}

interface Edit extends ProjectInstruction<"edit"> {

}

//extends ProjectInstruction because we need to know the project name
interface Generate extends ProjectInstruction<"generate"> {

}

//because in a message, we may not know project name yet
interface PresentableGenerate extends Instruction<"generate"> {
  project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableEdit extends Instruction<"edit"> {
  project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableReview extends Instruction<"review"> {
  project?: string | ProjectReference
}

interface Execute extends Instruction<"execute"> {
}

interface Command extends Instruction<"command"> {

}

interface Respond extends Instruction<"respond"> {

}

interface HandleCommand {
  handle(ctx: HandlerContext): Plan
}

interface HandleEvent<R extends GraphNode, M extends GraphNode> {
  handle(root: Match<R, M>): Plan
}

interface HandleResponse<T> {
  handle(response: Response<T>): Plan
}

/**
 * Context available to all handlers. Unique to a team.
 * Exposes a context root from which queries can be run,
 * using the given PathExpressionEngine
 */
interface HandlerContext {

  /**
   * Id of the team we're working on behalf of
   */
  teamId: string

  pathExpressionEngine: PathExpressionEngine

  /**
   * The root of this team's context. Allows execution
   * of path expressions.
   */
  contextRoot: GraphNode
}

enum Status {
  failure,
  success
}

interface Response<T> {

  msg(): string

  code(): number

  status(): Status

  body(): T
}

/**
 * A bunch of stuff to do asynchronously
 * Messages got to the bot.
 * Rugs are run straight away
 */
class Plan {

  messages: PlanMessage[] = [];

  instructions: ImmediatelyRunnable[] = [];

  public add?(thing: ImmediatelyRunnable | PlanMessage): this {
    if (thing instanceof ResponseMessage || thing instanceof DirectedMessage || thing instanceof LifecycleMessage) {
      this.messages.push(thing)
    }
    else {
      this.instructions.push(thing)
    }
    return this;
  }

  static ofMessage(m: PlanMessage): Plan {
    return new Plan().add(m);
  }
}

export type MessageMimeType = "application/x-atomist-slack+json" | "text/plain"

export abstract class MessageMimeTypes {
  public static SLACK_JSON: MessageMimeType = "application/x-atomist-slack+json"
  public static PLAIN_TEXT: MessageMimeType = "text/plain"
}

type MessageKind = "response" | "lifecycle" | "directed"

interface Message<T extends MessageKind> {
  kind: T
}

/**
 * Represents the response to the bot from a command
 */
export class ResponseMessage implements Message<"response"> {

  kind: "response" = "response"
  body: string;
  contentType: MessageMimeType = MessageMimeTypes.PLAIN_TEXT
  usernames?: string[] = [];
  channelNames?: string[] = [];

  constructor(body: string, contentType?: MessageMimeType) {
    this.body = body;
    if (contentType) {
      this.contentType = contentType;
    }
  }

  public addAddress?(address: MessageAddress): this {
    if (address instanceof UserAddress) {
      this.usernames.push(address.username);
    }
    else {
      this.channelNames.push(address.channelName);
    }
    return this;
  }
}

export class UserAddress {
  constructor(public username: string) { }
}

export class ChannelAddress {
  constructor(public channelName: string) { }
}

export type MessageAddress = UserAddress | ChannelAddress

/**
 * Uncorrelated message to the bot
 */
export class DirectedMessage implements Message<"directed"> {

  kind: "directed" = "directed"
  contentType: MessageMimeType = MessageMimeTypes.PLAIN_TEXT
  body: string;
  usernames?: string[] = [];
  channelNames?: string[] = [];

  constructor(body: string, address: MessageAddress, contentType?: MessageMimeType) {
    this.body = body;
    if (contentType) {
      this.contentType = contentType;
    }
    this.addAddress(address);
  }

  public addAddress?(address: MessageAddress): this {
    if (address instanceof UserAddress) {
      this.usernames.push(address.username);
    }
    else {
      this.channelNames.push(address.channelName);
    }
    return this;
  }
}

/**
 * Correlated, updatable messages to the bot
 */
export class LifecycleMessage implements Message<"lifecycle">{

  kind: "lifecycle" = "lifecycle"
  node: GraphNode;
  instructions?: Presentable<any>[] = [];
  lifecycleId: string;

  constructor(node: GraphNode, lifecycleId: string) {
    this.node = node;
    this.lifecycleId = lifecycleId;
  }

  public addAction?(instruction: Presentable<any>): this {
    this.instructions.push(instruction);
    return this;
  }
}

export type PlanMessage = ResponseMessage | DirectedMessage | LifecycleMessage

abstract class MappedParameters {
  static readonly GITHUB_REPO_OWNER: string = "atomist://github/repository/owner"
  static readonly GITHUB_REPOSITORY: string = "atomist://github/repository"
  static readonly SLACK_CHANNEL: string = "atomist://slack/channel"
  static readonly SLACK_TEAM: string = "atomist://slack/team"
  static readonly SLACK_USER: string = "atomist://slack/user"
  static readonly GITHUB_WEBHOOK_URL: string = "atomist://github_webhook_url"
}

export { MappedParameters }
export { Respond, Presentable, NonRespondable, Respondable, Instruction, Response, HandlerContext, Plan, Execute }
export { HandleResponse, HandleCommand, HandleEvent }
export { Edit, ProjectInstruction }
