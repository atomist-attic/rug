import {TreeNode, PathExpressionEngine, PathExpression, Match} from "../tree/PathExpression"
import {Parameter} from "./RugOperation"

interface RugCoordinate {
  readonly name: string
  readonly group: string
  readonly artifact: string
}

type InstructionKind = "generate" | "edit" | "review" | "execute" | "respond" | "command"

interface Secret {
  id: string //location/key of the secret
  name: string //the name which will be referenced from an Execution
}

type stringMap = { [s: string]: string; }

interface Instruction<T extends InstructionKind> {
  readonly name: string | RugCoordinate
  readonly parameters?: stringMap
  readonly kind: T
}

class Respondable<T extends InstructionKind> {
  instruction: Instruction<T>
  onSuccess?: Plan | Message | Respond
  onError?: Plan | Message | Respond
}

class Presentable<T extends InstructionKind> {
  instruction: Instruction<T> | PresentableGenerate | PresentableEdit | PresentableReview
  label?: string
}

// Location to a project.
// in the future, we could add things like github urls, orgs etc.
interface ProjectReference {

}

interface ProjectInstruction<T extends InstructionKind> extends Instruction<T> {
  project: string | ProjectReference
}

interface Review extends ProjectInstruction<"review"> {

}

interface Edit extends ProjectInstruction <"edit">{

}

//extends ProjectInstruction because we need to know the project name
interface Generate extends ProjectInstruction <"generate">{

}

//because in a message, we may not know project name yet
interface PresentableGenerate extends Instruction<"generate"> {
    project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableEdit extends Instruction<"edit"> {
    project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableReview extends Instruction<"review"> {
    project?: string | ProjectReference
}

interface Execute extends Instruction<"execute">{
  readonly secrets?: Secret[]
}

interface Command extends Instruction<"command">{

}

interface Respond extends Instruction<"respond">{

}

interface HandleCommand{
  handle(ctx: CommandContext): Plan | Message
}

interface HandleEvent<R extends TreeNode, M extends TreeNode> {
  handle(root: Match<R,M>): Plan | Message
}

interface HandleResponse<T>{
  handle(response: Response<T>): Plan | Message
}

interface CommandContext {
  pathExpressionEngine(): PathExpressionEngine
}

enum Status {
  failure,
  success
}

interface Response<T> {
  readonly msg?: string
  readonly code?: number
  readonly status: Status
  readonly body?: T
}

/**
A bunch of stuff to do asynchronously
Messages got to the bot.
Rugs are run straight away
*/

class Plan {
   private messages: Message[] = [];
   private instructions: Respondable<any>[] = [];
   public add?(thing: Respondable<any> | Message): this {
     if(thing instanceof Message){
       this.messages.push(thing)
     }else{
        this.instructions.push(thing)
     }
     return this;
   }
}
/**
Represents a Message to the bot.
Any rugs can contain unbound parameters, and the bot will try to fill them out
*/
class Message {
  text?: string;
  body?: Json;
  channelId?: string;
  instructions?: Presentable<any>[] = [];

  constructor(about: string | Json){
    if(typeof about == 'string'){
        this.text = about;
    }else{
        this.body = about;
    }
  }

  public addAction?(instruction: Presentable<any>): this {
    this.instructions.push(instruction)
    return this;
  }
}

//from https://github.com/Microsoft/TypeScript/issues/1897
interface Json {
	[x: string]: string | number | boolean | Date | Json | JsonArray;
}

interface JsonArray extends Array<string | number | boolean | Date | Json | JsonArray> { }

export {Respond, Presentable, Respondable, Instruction, Response, CommandContext, Plan, Message}
export {HandleResponse, HandleCommand, HandleEvent}
