
import {TreeNode,TextTreeNode,ParentAwareTreeNode,PathExpressionEngine} from "../../tree/PathExpression"
import {AstHelper} from "../AstHelper"

import {File} from "../../model/Core"

import * as scala from "./Types"

/**
 * Helpers for working with Scala classes. This shows a common pattern:
 * We work with a tree and Strings, but within that, encapsulate 
 * common operations and path expressions.
 */
export class ScalaHelper extends AstHelper {

    public constructor(pexe: PathExpressionEngine) {
        super(pexe)
    }

    /**
     * Add the import if not already imported.
     * Invalidates the file. Returns the new language type node (under file).
     */
    addImport(scalaNode: scala.ScalaSource, newImport: string): TextTreeNode {
        let fullNewImport = `import ${newImport}`

        if (scalaNode.value().indexOf(fullNewImport) == -1) {
            let firstImport = `//import[1]`

            this.pexe.with<TextTreeNode>(scalaNode, firstImport, existingImport => {
                let newValue = `${existingImport.value()}\n${fullNewImport}`
                //console.log(`Replacing [${existingImport.value()}] with [${newValue}]`)
                existingImport.update(newValue)
            })
        }
        else {
            //console.log(`Already has import ${newImport}`)
        }
    
        return super.reparseNodeUnderFile(scalaNode, "ScalaFile")
    }

}