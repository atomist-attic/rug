import {TreeNode, TextTreeNode} from "../../tree/PathExpression";
import * as helper from "../../tree/TreeHelper";
import {DecoratingPathExpressionEngine} from "../DecoratingPathExpressionEngine";
import * as yaml from "./Types";

/**
 * PathExpressionEngine decorator that returns Yaml type mixins
 * for value nodes.
 */
export class YamlPathExpressionEngine extends DecoratingPathExpressionEngine {

    protected decoratorFor(n: TreeNode): any {
        if ((<any>n).value) { // It's a text node
            let ttn = n as TextTreeNode

            console.log(`Decorating [${n}] with tags [${n.nodeTags()}]`)
            if (helper.hasTag(n, "Scalar")) {
                switch (ttn.value().charAt(0)) {
                    case '"':
                        return new yaml.QuotedValue(ttn)
                    case '>':
                        return new yaml.FoldedBlockScalarStyle(ttn)
                    case '|':
                        return new yaml.LiteralBlockScalarStyle(ttn)
                    default:
                        return new yaml.RawValue(ttn)
                }
            } else if (helper.hasTag(n, "Sequence")) {
                return new yaml.SequenceOps(ttn)
            }
        }
        // If we didn't match anything
        return null
    }
}
