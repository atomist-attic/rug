import {BaseParameter} from './RugOperation'
//used by annotation functions

function set_metadata(obj: any, key: string, value: any){
  Object.defineProperty(obj, key, {value: value, writable: false, enumerable: true})
}


function get_metadata(obj: any, key: string){
   let desc =  Object.getOwnPropertyDescriptor(obj, key);
   if((desc == null || desc == undefined) && (obj.prototype != undefined)){
     desc = Object.getOwnPropertyDescriptor(obj.prototype, key);
   }
   if(desc != null || desc != undefined){
     return desc.value;
   }
   return null;
}


/**
* Decorator for parameters. Adds to object properties
*/
function Parameter(details: BaseParameter) {
  return function (target: any, propertyKey: string) {
    var params = get_metadata(target, "__parameters");
    if(params == null){
      params = []
    }
    details["name"] = propertyKey
    details["decorated"] = true
    params.push(details);
    set_metadata(target, "__parameters", params);
  }
}

/**
* Decorator for editors. Use this intead of implementing the editor interface.
*/

function ruglike(kind: string) {
  return function (name: string, description: string) {
    return function(ctr: Function) {
      if (typeof ctr.prototype[kind] !== "function") {
        throw new Error(`${kind} must be function that takes a Project as its first argument.`)
      }
      ctr.prototype["__name"] = name;
      ctr.prototype["__description"] = description
    }
  }
}

let Generator = ruglike("populate")
let Reviewer = ruglike("review")
let Editor = ruglike("edit")

/**
* Decorator for tags. Sets tags on the class
*/

function Tags(...tags: string[]) {
  return function(target: any) {
    target.prototype["__tags"] = tags
  }
}
export {Parameter, Editor, Generator, Reviewer, Tags}