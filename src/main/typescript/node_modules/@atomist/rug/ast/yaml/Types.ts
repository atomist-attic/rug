import {TextTreeNode} from "../../tree/PathExpression"

/**
 * Extended by classes that know how to handle YAML strings or sequences.
 * We need to transform them on return and on update.
 */
export interface YamlStringOps {

    /**
     * Returns the actual text, not the raw value,
     * which may contain quotes etc.
     */
    text(): string

    /**
     * Update the actual text, taking care of quotes, newlines etc.
     */
    updateText(to: string): void
}

export type YamlString = YamlStringOps & TextTreeNode

/**
 * String without quotes or newlines. Leave it alone.
 */
export class RawValue implements YamlStringOps {

    constructor(private node: TextTreeNode) {}

    text() {
        return this.node.value()
    }

    updateText(to: string) {
        this.node.update(to)
    }
}

/**
 * String enclosed in "". Simply strip them.
 */
export class QuotedValue implements YamlStringOps {

    constructor(private node: TextTreeNode) {}

    text() {
        return this.node.value().slice(1, this.node.value().length - 1)
    }

    updateText(to: string) {
        let newValue = `"${to}"`
        console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using >. Strip newlines.
 */
// TODO various ways of handling trailing newlines: -, +
export class FoldedBlockScalarStyle implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '>') throw new Error("Illegal argument: Must begin with >")
        if (raw.charAt(1) != '\n') throw new Error("Illegal argument: Must begin with >\n")
        let index = 2
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(2)
    }

    text() {
        return this.node.value().substr(this.leading.length).replace("\n", " ")
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * String using |. Strip newlines.
 */
// TODO various ways of handling trailing newlines: -, +
export class LiteralBlockScalarStyle implements YamlStringOps {

    // Indent for each line
    private indent: string
    private leading: string

    constructor(private node: TextTreeNode) {
        let raw = node.value()
        if (raw.charAt(0) != '|') throw new Error("Illegal argument: Must begin with |")
        if (raw.charAt(1) != '\n') throw new Error("Illegal argument: Must begin with |\n")
        let index = 2
        let ch = raw.charAt(index)
        while (ch == ' ' || ch == '\t' || ch == '\n') {
            ch = raw.charAt(++index)
        }
        this.leading = raw.substr(0, index)
        this.indent = this.leading.substring(2)
    }

    text() {
        return this.node.value().substr(this.leading.length).replace("\n", " ")
    }

    updateText(to: string) {
        let newValue = `${this.leading}${to}`
        console.log(`Update from [${this.node.value()}] to [${newValue}]`)
        this.node.update(newValue)
    }
}

/**
 * Works with raw node value to add and remove sequence elements,
 * observing YAML formatting.
 */
export class SequenceOps {

    constructor(private node: TextTreeNode) {}

    addElement() {
        throw new Error("Not yet implemented: addElement")
    }

    removeElement() {
        throw new Error("Not yet implemented: removeElement")
    }
}

export type Sequence = SequenceOps & TextTreeNode
