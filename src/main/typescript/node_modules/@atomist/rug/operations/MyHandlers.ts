import {EventHandler, Instruction, Response, CommandHandler, CommandContext, Plan, Message} from './Handlers'
import {TreeNode, Match, PathExpression} from '../tree/PathExpression'
import {parameter, Secret, secret} from '../operations/RugOperation'
import {Project} from '../model/Core'

/**

Proposal:
- Rename Handler to EventHandler
- Remove Executors, and introduce CommandHandlers and Executions

- CommandHandlers run Commands
- Commands are submitted by users via the bot/slack etc...
- CommandHandlers can register bot intent
- CommandHandlers/Commands can have access to secrets
- They are basically the things that @cd uses to do all his fancy botlets.

- Both Event and Command Handlers return Plan | Message
- Plan can contain Executions.
- Executions represent deferred execution
  of some function that (currently) lives in the JVM in the ExecutionRegistry
  (formally CommandRegistry?).
- Success/Errors from Executions can be handled by registering callbacks.
  These callbacks return Plans too!
- Queries are (nearly) always performed via PathExpressions
   - A query is a non-side-effecting retrieval of some data

- Success/Error responses are in a standard format (as per HTTP)
   - code
   - status
   - body - this can be anything at all, even a JVM object

Rationale:
- Easy to explain: rugs can be done via CLI, Handlers are at runtime
- Programming model is asynchronous everywhere!
- First class bot Commands required!
- Executors model was confusing

QUESTION:
- Ideally these Execution callbacks would be serializable such that we can store and run them elsewhere/later
- How do we get things like the PXE in to CommandHandlers?
   - perhaps a "context" type thing with the PXE and other stuff on it?
- Should reviewers be exposed via PXE?
- Should we externalise parameter definitions for rugs and make them common across DSL and TS?
- How do we remove the duplication/guessing around parameter declarations?
- How do we easily allow chaining of executions (if at all)?
   - allow onSuccess also be an execution?
- jess: why aren't messages just executions?
TODO:
- Add error/success callbacks to editors/generators/reviewers

**/

//NOTE: use case 1: Reopen an issue twice and handle success/failure


export let simpleHandler: EventHandler<Issue,Issue> = {

  expression: new ClosedIssues(),

  name: "ClosedIssueReopener",
  description: "Reopens closed issues",
  tags: ["github", "issues"],
  handle(match: Match<Issue,Issue>): Plan {
    let issue = match.root()
    let reopen = issue.reopen

    reopen.onSuccess = {text: `Issue ${issue.number} has been reopened successfully`}
    reopen.onError = {name: "sendFailureMessage", parameters: {issue: issue, who: "jess", blah: sendFailureMessage}}
    return new Plan()
      .add(reopen)
  }
}

// try to reopen the issue one more time!
export function sendFailureMessage(error: Response<Issue>, p: any) : Plan {
  let issue = error.body
  return new Plan()
    .add(new Message(`Issue ${issue.number} was not reopened, trying again`))
    .add(p.repeat.onError(new Message(`Issue ${issue.number} was not reopened. Giving up!`)))
}

//NOTE use case 2: run an editor/reviewer across a bunch of repos (the old Executor)

class LicenseAdder implements CommandHandler {
  name = "LicenseAdder"
  description = "Runs the SetLicense editor on a bunch of my repos"
  tags = ["github", "license"]
  intent = ["add license"]

  @parameter({description: "The name of the license", pattern: "^.*$"})
  license: string;

  handle(command: CommandContext) : Plan {

    let result = new Plan()
    // result.add(new Message("blah").addAction())
    var match: Match<TreeNode,Project> = command.pathExpressionEngine()
         .evaluate<TreeNode,Project>("/Team()/Owns::Org()/Has::Repo()")

    match.matches().forEach(project => {
      result.add({name: "blah", kind: "editor", project: project})
    })
    return result;
  }
}

//NOTE: use case 3: handle a Command from the bot (via intent or otherwise)
//1. First class intent
//2. First class secrets
//3. As per other Rugs - declared params are passed in to the command
class ListIssuesHandler implements CommandHandler {
  name = "ListIssuesHandler"
  description = "Lists open github issues in slack"
  tags = ["github", "issues"]
  intent = ["list issues"]

  @parameter({description: "Days", pattern: "^.*$", maxLength: 100, required: false })
  days = 1

  @secret({id: "user_token"})
  token: string = "somthing"

  handle(ctx: CommandContext) : Message {
    var match: Match<Issue,Issue> = ctx.pathExpressionEngine()
      .evaluate<Issue,Issue>("/Repo()/Issue[@raisedBy='kipz']")
    let issues = match.matches();
    if (issues.length > 0) {
              let attachments = `{"attachments": [` + issues.map(i => {
                 let text = JSON.stringify(`#${i.number}: ${i.title}`)
                 if (i.state == "closed") {
                     return `{
                   "fallback": ${text},
                   "author_icon": "http://images.atomist.com/rug/issue-closed.png",
                   "color": "#bd2c00",
                   "author_link": "${i.issueUrl}",
                   "author_name": ${text}
                }`
                 }
                 else {
                     return `{
                 "fallback": ${text},
                 "author_icon": "http://images.atomist.com/rug/issue-open.png",
                 "color": "#6cc644",
                 "author_link": "${i.issueUrl}",
                 "author_name": ${text}
              }`
                 }
             }).join(",") + "]}"
             return {text: attachments}
         }else{
            return {text: "You are not crushin' it right now!"}
         }
  }
}

// NOTE: use case 4: search youtube for kitty videos and post results to slack
// no params - just take Command
export let kitties: CommandHandler = {
  name: "ShowMeTheKitties",
  description: "Search Youtube for kitty videos and post results to slack",
  tags: ["kitty", "youtube", "slack"],
  intent: ["show me kitties"],

  handle(command: CommandContext) : Plan {
    let result = new Plan()
    result.add({     kind: "execution",
                        name: "HTTP",
                        parameters: {method: "GET", url: "http://youtube.com?search=kitty&safe=true", as: "JSON"},
                        onSuccess: kitties,
                        onError: {text: "No kitties for you today!"}})
    return result;
  }
}

function showKitties(response: Response<Object>) : Message {
  let results = response.body as any;
  return new Message(results.urls.join(","))
}

// stuff associated with types/executions that should have typings

interface Issue extends TreeNode {
  reopen: Instruction<"execute">
  title: string
  number: string
  state: string
  issueUrl: string
}

class ClosedIssues implements PathExpression<Issue,Issue> {
  expression: string = "/issues/[.state() = 'closed']"
}
