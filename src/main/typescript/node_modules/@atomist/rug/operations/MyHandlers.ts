import {EventHandler, Respond, ResponseHandler, Instruction, Response, CommandRunner, CommandContext, Plan, Message} from './Handlers'
import {TreeNode, Match, PathExpression} from '../tree/PathExpression'
import {parameter, Secret, secret, handler, runner, responder, tags, intent} from '../operations/RugOperation'
import {Project} from '../model/Core'

/**

Proposal:
- Rename Handler to EventHandler
- Remove Executors, and introduce CommandHandlers and Executions

- CommandHandlers run Commands
- Commands are submitted by users via the bot/slack etc...
- CommandHandlers can register bot intent
- CommandHandlers/Commands can have access to secrets
- They are basically the things that @cd uses to do all his fancy botlets.

- Both Event and Command Handlers return Plan | Message
- Plan can contain Executions.
- Executions represent deferred execution
  of some function that (currently) lives in the JVM in the ExecutionRegistry
  (formally CommandRegistry?).
- Success/Errors from Executions can be handled by registering callbacks.
  These callbacks return Plans too!
- Queries are (nearly) always performed via PathExpressions
   - A query is a non-side-effecting retrieval of some data

- Success/Error responses are in a standard format (as per HTTP)
   - code
   - status
   - body - this can be anything at all, even a JVM object

Rationale:
- Easy to explain: rugs can be done via CLI, Handlers are at runtime
- Programming model is asynchronous everywhere!
- First class bot Commands required!
- Executors model was confusing

QUESTION:
- Ideally these Execution callbacks would be serializable such that we can store and run them elsewhere/later
- How do we get things like the PXE in to CommandHandlers?
   - perhaps a "context" type thing with the PXE and other stuff on it?
- Should reviewers be exposed via PXE?
- Should we externalise parameter definitions for rugs and make them common across DSL and TS?
- How do we remove the duplication/guessing around parameter declarations?
- How do we easily allow chaining of executions (if at all)?
   - allow onSuccess also be an execution?
- jess: why aren't messages just executions?
TODO:
- Add error/success callbacks to editors/generators/reviewers

**/

//NOTE: use case 1: Reopen an issue twice and handle success/failure


@handler("ClosedIssueReopener","Reopens closed issues", new ClosedIssues())
@tags("github", "issues")

class SimpleHandler implements EventHandler<Issue,Issue> {
  handle(match: Match<Issue,Issue>): Plan {
    let issue = match.root()
    let reopen = issue.reopen
    reopen.onSuccess = {text: `Issue ${issue.number} has been reopened successfully`}
    reopen.onError = {name: "sendFailureMessage", parameters: {issue: issue, who: "jess"}}
    return new Plan()
      .add(reopen)
  }
}

@responder("IssueClosedResponder", "Logs failed issue reopen attempts")
class IssueReopenFailedResponder implements ResponseHandler<Issue> {

  @parameter({description: "Name of recipient", pattern: "^.*$"})
  who: string

  respond(response: Response<Issue>): Plan {
    let issue = response.body
    let msg = new Message(`Issue ${issue.number} was not reopened, trying again`)
    msg.channelId = this.who
    return new Plan()
      .add(msg)
  }
}

//NOTE use case 2: run an editor/reviewer across a bunch of repos (the old Executor)

@runner("LicenseAdder","Runs the SetLicense editor on a bunch of my repos")
@tags("github", "license")
@intent("add license")
class LicenseAdder implements CommandRunner {

  @parameter({description: "The name of the license", pattern: "^.*$"})
  license: string;

  run(command: CommandContext) : Plan {
    let result = new Plan()
    var match: Match<TreeNode,Project> = command.pathExpressionEngine()
         .evaluate<TreeNode,Project>("/Team()/Owns::Org()/Has::Repo()")
    match.matches().forEach(project => {
      result.add({name: "blah", kind: "editor", project: project})
    })
    return result;
  }
}

//NOTE: use case 3: handle a Command from the bot (via intent or otherwise)
//1. First class intent
//2. First class secrets
//3. As per other Rugs - declared params are passed in to the command

@runner("ListIssuesHandler","Lists open github issues in slack")
@tags("github", "issues")
@intent("list issues")
class IssueLister implements CommandRunner {

  @parameter({description: "Days", pattern: "^.*$", maxLength: 100, required: false })
  days = 1

  @secret({id: "user_token"})
  token: string = "somthing"

  run(ctx: CommandContext) : Message {
    var match: Match<Issue,Issue> = ctx.pathExpressionEngine()
      .evaluate<Issue,Issue>("/Repo()/Issue[@raisedBy='kipz']")
    let issues = match.matches();
    if (issues.length > 0) {
              let attachments = `{"attachments": [` + issues.map(i => {
                 let text = JSON.stringify(`#${i.number}: ${i.title}`)
                 if (i.state == "closed") {
                     return `{
                   "fallback": ${text},
                   "author_icon": "http://images.atomist.com/rug/issue-closed.png",
                   "color": "#bd2c00",
                   "author_link": "${i.issueUrl}",
                   "author_name": ${text}
                }`
                 }
                 else {
                     return `{
                 "fallback": ${text},
                 "author_icon": "http://images.atomist.com/rug/issue-open.png",
                 "color": "#6cc644",
                 "author_link": "${i.issueUrl}",
                 "author_name": ${text}
              }`
                 }
             }).join(",") + "]}"
             return {text: attachments}
         }else{
            return {text: "You are not crushin' it right now!"}
         }
  }
}

// NOTE: use case 4: search youtube for kitty videos and post results to slack
// no params - just take Command
@runner("ShowMeTheKitties","Search Youtube for kitty videos and post results to slack")
@tags("kitty", "youtube", "slack")
@intent("show me kitties")
class KittieFetcher implements CommandRunner {
  run(command: CommandContext) : Plan {
    let result = new Plan()
    result.add({kind: "execution",
                name: "HTTP",
                parameters: {method: "GET", url: "http://youtube.com?search=kitty&safe=true", as: "JSON"},
                onSuccess: {kind: "respond", name: "Kitties"},
                onError: {text: "No kitties for you today!"}})
    return result;
  }
}

@responder("Kitties", "Prints out kitty urls")
class KittiesResponder implements ResponseHandler<Object> {
  respond(response: Response<Object>) : Message {
    let results = response.body as any;
    return new Message(results.urls.join(","))
  }
}

// stuff associated with types/executions that should have typings

interface Issue extends TreeNode {
  reopen: Instruction<"execute">
  title: string
  number: string
  state: string
  issueUrl: string
}

class ClosedIssues implements PathExpression<Issue,Issue> {
  expression: string = "/issues/[.state() = 'closed']"
}
