
/**
 *  Returned when a PathExpression is evaluated
*/
interface Match<R,N> {

  root(): R

  matches(): N[]
}

/**
 * Object containing a path expression. Facilitates reuse.
 */
class PathExpression<R,N> {

  constructor(public expression: string) {}

}

/**
 * Operations common to all tree nodes.
 */
interface TreeNode {

  nodeName(): string

  nodeType(): string[]

  value(): string

  update(newValue: string)

  children(): TreeNode[]

}

interface TypeProvider extends DynamicType {

    typeName: string

    find(context: TreeNode): TreeNode[]

}

/*
 * Interface to execute path expressions and return Match objects.
 */
interface PathExpressionEngine {

/**
 * Add a dynamic type. Can be used as a fluent API.
 */
  addType(dt: DynamicType): PathExpressionEngine

  evaluate<R extends TreeNode,N extends TreeNode>(root: R, expr: PathExpression<R,N>): Match<R,N>

  /**
  * Execute the given function on the nodes returned by the given path expression
  */
  with<N extends TreeNode>(root: TreeNode, expr: string,
            f: (n: N) => void): void

/**
 * Return a single match. Throw an exception otherwise.
 */
  scalar<R extends TreeNode,N extends TreeNode>(root: R, expr: PathExpression<R,N>): N

 /**
 * Cast the present node to the given type
 */
  as<N extends TreeNode>(root, name: string): N

  // Find the children of the current node of this time
  children<N extends TreeNode>(root, name: string): N[]

}

/**
 * Tag interface for dynamic types such as microgrammars
 */
interface DynamicType {

}

/**
 * Dynamic type for a microgrammar. Pass to PathExpression.addType method
 */
class Microgrammar implements DynamicType {

      constructor(public name: string, public grammar: string) {}
}

export {Match}
export {PathExpression}
export {PathExpressionEngine}
export {TreeNode}
export {TypeProvider}
export {DynamicType}
export {Microgrammar}
